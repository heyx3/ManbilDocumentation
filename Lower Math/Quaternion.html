 <!DOCTYPE html>
 <html>
    
    <head>
        <title>Class: Quaternion</title>
        <link type="text/css" rel="stylesheet" href="../MainCSS.css" />
    </head>

    <body>

        <h1>Quaternion</h1>

        <p>A mathematical object that represents rotation transforms more efficiently and accurately than a matrix.</p>

        <h2>Metadata</h2>
        <p>Located in "Math/Lower Math/Quaternion.h". Has a .cpp file in the same location. Part of the <a href="../Lower Math.html">Lower Math</a> system.</p>

        <br class="SectionDivider" />

        <h2>Declaration</h2>
        <code class="CodeDecl">class Quaternion;</code>
        <p />

        <br class="SectionDivider" />

        <h2>Sub-types</h2>
        <p>None.</p>

        <br class="SectionDivider" />

        <h2>Constants</h2>
        <p>None.</p>

        <br class="SectionDivider" />

        <h2>Static Fields</h2>
        <p>None.</p>

        <br class="SectionDivider" />

        <h2>Static Functions</h2>
        <ul class="DeclarationList">
            <li>
                <a name="Slerp" />
                <code class="CodeDecl">public Quaternion Slerp(Quaternion start, Quaternion end, float t, bool areNormalized)</code>
                <ul>
                    <li>Interpolates between the given start and end.</li>
                    <li>Slower.</li>
                    <li>Not commutative (<code>Slerp(start, end, t) != Slerp(end, start, 1.0f - t)</code>).</li>
                    <li>Keeps a constant velocity.</li>
                    <li>Always finds the shortest path from start to end.</li>
                </ul>
            </li>
            <li>
                <a name="NLerp" />
                <code class="CodeDecl">public Quaternion NLerp(Quaternion start, Quaternion end, float t)</code>
                <ul>
                    <li>Interpolates between the given start and end.</li>
                    <li>Faster.</li>
                    <li>Is commutative (<code>Slerp(start, end, t) == Slerp(end, start, 1.0f - t)</code>).</li>
                    <li>Does not keep a constant velocity.</li>
                    <li>Always finds the shortest path from start to end.</li>
                </ul>
            </li>
            <li>
                <a name="NLerpFast" />
                <code class="CodeDecl">public Quaternion NLerpFast(Quaternion start, Quaternion end, float t)</code>
                <ul>
                    <li>Interpolates between the given start and end.</li>
                    <li>Faster and less accurate form of NLerp.</li>
                    <li>Is commutative (<code>Slerp(start, end, t) == Slerp(end, start, 1.0f - t)</code>).</li>
                    <li>Does not keep a constant velocity.</li>
                    <li>Always finds the shortest path from start to end.</li>
                </ul>
            </li>
        </ul>
        <ul class="DeclarationList">
            <li>
                <a name="MultiplyQuaternion" />
                <code class="CodeDecl">public Quaternion Multiply(Quaternion&amp; lhs, const Quaternion&amp; rhs)</code>
                <ul>
                    <li>Multiplies the two quaternions.</li>
                    <li>Yields a new quaternion whose rotation is equal to "rhs"'s rotation followed by "lhs"'s rotation.</li>
                </ul>
            </li>
            <li>
                <a name="MultiplyVector" />
                <code class="CodeDecl">public Quaternion Multiply(Quaternion&amp; lhs, const Vector3f&amp; rhs)</code>
                <ul>
                    <li>Multiplies the quaternion by the given vector.</li>
                    <li>This is one step of the computation when rotating a vector by a quaternion.</li>
                </ul>
            </li>
        </ul>

        <br class="SectionDivider" />

        <h2>Member Fields</h2>
        <ul class="DeclarationList">
            <li>
                <a name="x" />
                <code class="CodeDecl">public float x;</code>
                <ul>
                    <li>The X component of this quaternion.</li>
                </ul>
            </li>
            <li>
                <a name="y" />
                <code class="CodeDecl">public float y;</code>
                <ul>
                    <li>The Y component of this quaternion.</li>
                </ul>
            </li>
            <li>
                <a name="z" />
                <code class="CodeDecl">public float z;</code>
                <ul>
                    <li>The Z component of this quaternion.</li>
                </ul>
            </li>
            <li>
                <a name="w" />
                <code class="CodeDecl">public float w;</code>
                <ul>
                    <li>The W component of this quaternion.</li>
                </ul>
            </li>
        </ul>

        <br class="SectionDivider" />

        <h2>Operators</h2>
        <ul class="DeclarationList">
            <li>
                <a name="operator-" />
                <code class="CodeDecl">public Quaternion operator-(void) const</code>
                <ul>
                    <li>Gets the inverse of this quaternion.</li>
                    <li>The resulting quaternion represents the opposite of this quaternion's rotation.</li>
                </ul>
            </li>
            <li>
                <a name="operator+" />
                <code class="CodeDecl">public Quaternion operator+(const Quaternion&amp; q) const</code>
                <ul>
                    <li>Adds the two quaternions together.</li>
                </ul>
            </li>
            <li>
                <a name="operator-" />
                <code class="CodeDecl">public Quaternion operator-(const Quaternion&amp; q) const</code>
                <ul>
                    <li>Subtracts the given quaternion from this one.</li>
                </ul>
            </li>
            <li>
                <a name="operator*" />
                <code class="CodeDecl">public Quaternion operator*(float scale) const</code>
                <ul>
                    <li>Multiplies this quaternion's components by the given scale.</li>
                </ul>
            </li>
            <li>
                <a name="operator/" />
                <code class="CodeDecl">public Quaternion operator/(float invScale) const</code>
                <ul>
                    <li>Divides this quaternion's components by the given scale.</li>
                </ul>
            </li>
        </ul>

        <h2>Constructors</h2>
        <ul class="DeclarationList">
            <li>
                <a name="DefaultConstructor" />
                <code class="CodeDecl">public Quaternion(void)</code>
                <ul>
                    <li>Creates a quaternion that represents a rotation of 0 rad.</li>
                </ul>
            </li>
            <li>
                <a name="ComponentConstructor" />
                <code class="CodeDecl">public Quaternion(float x, float y, float z, float w)</code>
                <ul>
                    <li>Creates a quaternion with the given components.</li>
                </ul>
            </li>
            <li>
                <a name="AxisAngleConstructor" />
                <code class="CodeDecl">public Quaternion(Vector3f axisOfRotation, float rotInRadians)</code>
                <ul>
                    <li>Creates a quaternion representing a rotation of the given amount around the given axis.</li>
                    <li>If the given axis isn't normalized, then magnitude of any vector this quaternion rotates is undefined.</li>
                </ul>
            </li>
            <li>
                <a name="TwoRotationsConstructor" />
                <code class="CodeDecl">public Quaternion(Quaternion firstRotation, Quaternion secondRotation)</code>
                <ul>
                    <li>Creates a quaternion representing the first given rotation followed by the second given rotation.</li>
                </ul>
            </li>
            <li>
                <a name="FromToConstructor" />
                <code class="CodeDecl">public Quaternion(Vector3f from, Vector3f to)</code>
                <ul>
                    <li>Creates a quaternion representing a rotation that would transform "from" into "to".</li>
                    <li>For this constructor to work correctly, both direction vectors must be normalized.</li>
                </ul>
            </li>
        </ul>

        <br class="SectionDivider" />

        <h2>Member Functions</h2>
        <ul class="DeclarationList">
            <li>
                <a name="Rotate" />
                <code class="CodeDecl">public void Rotate(Vector3f&amp; v) const</code>
                <ul>
                    <li>Applies this quaternion's rotation to the given vector.</li>
                </ul>
            </li>
            <li>
                <a name="Rotated" />
                <code class="CodeDecl">public Vector3f Rotated(Vector3f v) const</code>
                <ul>
                    <li>Applies this quaternion's rotation to the given vector.</li>
                </ul>
            </li>
        </ul>
        <ul class="DeclarationList">
            <li>
                <a name="Dot" />
                <code class="CodeDecl">public float Dot(Quaternion other) const</code>
                <ul>
                    <li>Gets the dot product of this quaternion and the given one.</li>
                </ul>
            </li>
        </ul>
        <ul class="DeclarationList">
            <li>
                <a name="Normalize" />
                <code class="CodeDecl">public void Normalize(void)</code>
                <ul>
                    <li>Normalizes this quaternion.</li>
                </ul>
            </li>
            <li>
                <a name="Normalized" />
                <code class="CodeDecl">public Quaternion Normalized(void) const</code>
                <ul>
                    <li>Normalizes this quaternion.</li>
                </ul>
            </li>
            <li>
                <a name="FastNormalize" />
                <code class="CodeDecl">public void FastNormalize(void)</code>
                <ul>
                    <li>Normalizes this quaternion.</li>
                    <li>Uses a fast and faily accurate approximation.</li>
                </ul>
            </li>
            <li>
                <a name="FastNormalized" />
                <code class="CodeDecl">public Quaternion FastNormalized(void) const</code>
                <ul>
                    <li>Normalizes this quaternion.</li>
                    <li>Uses a fast and faily accurate approximation.</li>
                </ul>
            </li>
        </ul>
        <ul class="DeclarationList">
            <li>
                <a name="ToMatrix" />
                <code class="CodeDecl">public void ToMatrix(Matrix4f&amp; out, bool amINormalized = false) const</code>
                <ul>
                    <li>Sets the given matrix to represent the same rotation as this quaternion.</li>
                    <li>Takes in whether this quaterion needs to be normalized first.</li>
                </ul>
            </li>
            <li>
                <a name="GetAxisAngle" />
                <code class="CodeDecl">public Vector4f GetAxisAngle(void) const</code>
                <ul>
                    <li>Gets the axis this quaternion rotates points around and the angle it rotates them by.</li>
                    <li>Returns the results as a <a href="Vector4f.html">Vector4f</a>: the XYZ components are the angle and the W component is the axis.</li>
                    <li><div class="CodeSample">
                        <code>
                            //The following code prints "0, 0, 1, 89.9995". <br />
                            Quaternion quat(Vector3f(0.0f, 0.0f, 1.0f), BasicMath::DegToRad(90.0f)); <br />
                            Vector4f result = quat.GetAxisAngle(); <br />
                            std::cout << result.x << ", " << result.y << ", " << result.z << ", " << <br />
&emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp;BasicMath::RadToDeg(result.w) << "\n"; <br />
                            <br />
                            //The following code prints "0, 0, -1, 89.9995". <br />
                            quat = Quaternion(Vector3f(0.0f, 0.0f, 1.0f), BasicMath::DegToRad(-90.0f)); <br />
                            result = quat.GetAxisAngle(); <br />
                            std::cout << result.x << ", " << result.y << ", " << result.z << ", " << <br />
&emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp;BasicMath::RadToDeg(result.w) << "\n";
                        </code>
                    </div></li>
                </ul>
            </li>
            <li>
                <a name="GetEulerAngles" />
                <code class="CodeDecl">public Vector4f GetEulerAngles(void) const</code>
                <ul>
                    <li>Gets the euler angles of the rotation this quaternion represents.</li>
                    <li><div class="CodeSample">
                        <code>
                            //The following code prints '1.045, -1.23, 0.001' within floating-point error. <br />
                            Quaterion rotX(Vector3f(1.0f, 0.0f, 0.0f), 1.045f), <br />
&emsp; &emsp; &emsp; &emsp; &emsp; rotY(Vector3f(0.0f, 1.0f, 0.0f), -1.23f), <br />
&emsp; &emsp; &emsp; &emsp; &emsp; rotZ(Vector3f(0.0f, 0.0f, 1.0f), 0.001f)); <br />
                            Quaternion finalRot(rotX, Quaternion(rotY, rotZ)); <br />
                            Vector3f euler = finalRot.GetEulerAngles(); <br />
                            std::cout << euler.x << ", " << euler.y << ", " << euler.z << "\n";
                        </code>
                    </div></li>
                </ul>
            </li>
        </ul>

        <br class="SectionDivider" />

        <h2>Usage</h2>
        <p>When representing generic transformations potentially involving translation, rotation, scaling,
           and more, you should use a matrix. When representing only rotation, you should use a quaternion.</p>
        <div class="CodeSample">
            <code>
                Quaternion rot90AroundZ(Vector3f(0.0f, 0.0f, 1.0f), BasicMath::DegToRad(90.0f)); <br />
                Vector3f point(1.0f, 0.0f, 0.0f), <br />
&emsp; &emsp; &emsp; &emsp; &emsp;rotatedPoint = rot90AroundZ.Rotated(point); <br />
                std::cout << rotatedPoint.x << ", " << rotatedPoint.y << ", " << rotatedPoint.z << "\n"; //Prints '0.0f, 1.0f, 0.0f'. <br />
                <br />
                Quaternion posToNeg(Vector3f(1.0f, 1.0f, 1.0f).Normalized(), <br />
&emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; Vector3f(-1.0f, -1.0f, -1.0f).Normalized()); <br />
                point = posToNeg.Rotated(Vector3f(1.0f, 1.0f, 1.0f)); <br />
                std::cout << point.x << ", " << point.y << ", " << point.z << "\n"; //Prints '-1, -1, -1'. <br />
                point = posToNeg.Rotated(Vector3f(-1.0f, -1.0f, -1.0f)); <br />
                std::cout << point.x << ", " << point.y << ", " << point.z << "\n"; //Prints '1, 1, 1'. <br />
                <br />
                Quaternion rot90AroundZThenPosToNeg(rot90AroundZ, posToNeg); <br />
                point = rot90AroundZThenPosToNeg.Rotated(Vector3f(1.0f, 1.0f, 1.0f)); <br />
                //The above line did the following transformations: <br />
                // -Starting with { 1, 1, 1 }. <br />
                // -Rotated 90 degrees around the Z to get { -1, 1, 1 }. <br />
                // -Rotated with the "posToNeg" quaternion to get { 1, -1, -1 }. <br />
                std::cout << point.x << ", " << point.y << ", " << point.z << "\n"; //Prints '1, -1, -1'. <br />
            </code>
        </div>

    </body>

 </html>