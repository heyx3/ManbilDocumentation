 <!DOCTYPE html>
 <html>
    
    <head>
        <title>System: Basic Rendering</title>
        <link type="text/css" rel="stylesheet" href="MainCSS.css" />
    </head>

    <body>

        <h1>"Basic Rendering" system</h1>

        <p>
            Contains the basic, low-level rendering system in the engine.
            Graphics rendering is generally done by passing sets of triangles into a "vertex shader"
            (which transforms the triangles into screen coordinates), then a "pixel/fragment shader"
            (which outputs the color of any given point on the triangles' surfaces).
            Occasionally a "geometry shader" may used between the vertex and fragment shaders to manipulate the passed-in shapes,
            in which case the vertex data may not necessarily be organized into triangles.
        </p>
        <p>
            The combination of a specific vertex and fragment (and optionally geometry) shader is often referred to as a "material".
        </p>

        <br class="SectionDivider" />

        <h2>Metadata</h2>
        <p>Located in "Remderomg/Basic Rendering". Builds off of the <a href="Higher Math.html">Higher Math</a> system.</p>

        <br class="SectionDivider" />

        <div class="TextSection">
            <h2>Classes/files</h2>
            <ul>
                <li>
                    <a href="Basic Rendering/OpenGLIncludes.html">OpenGLIncludes.h</a>
                    <ul>
                        <li>Provides the OpenGL API as well as some useful enums and typedefs.</li>
                    </ul>
                </li>
                <li>
                    <a href="Basic Rendering/ScreenClearer.html">ScreenClearer</a>
                    <ul>
                        <li>Clears the screen (or the currently-bound render target) to some given color/depth/stencil values.</li>
                    </ul>
                </li>
                <li>
                    <a href="Basic Rendering/RenderingState.html">RenderingState</a>
                    <ul>
                        <li>Represents information about rendering state such as which faces to cull or which pixels/fragments to ignore based on alpha.</li>
                    </ul>
                </li>
                <li>
                    <a href="Basic Rendering/BlendMode.html">BlendMode</a>
                    <ul>
                        <li>Represents information about blending state. Provides several default blending presets such as "Opaque", "Transparent", and "Additive".</li>
                    </ul>
                </li>
                <li>
                    <a href="Basic Rendering/RenderIOAttributes.html">RenderIOAttributes</a>
                    <ul>
                        <li>Describes shader input or output data, such as the attributes of the vertices passed into the vertex shader.</li>
                    </ul>
                </li>
                <li>
                    <a href="Basic Rendering/MeshData.html">MeshData</a>
                    <ul>
                        <li>Represents a set of vertices and (optionally) indices.</li>
                        <li>Also optionally stores a copy of the vertex/index data on the CPU for easy access.</li>
                    </ul>
                </li>
                <li>
                    <a href="Basic Rendering/Mesh.html">Mesh</a>
                    <ul>
                        <li>An object with one or more MeshData "submeshes", as well as a <a href="Higher Math/TransformObject.html">Transform</a>.</li>
                        <li>Only one submesh is active at a time.</li>
                    </ul>
                </li>
                <li>
                    <a href="Basic Rendering/Vertices.html">Vertices.h</a>
                    <ul>
                        <li>Defines several useful vertex types with commonly-used data such as position, UVs, and normals.</li>
                    </ul>
                </li>
                <li>
                    <a href="Basic Rendering/GLVectors.html">GLVectors</a>
                    <ul>
                        <li>Defines floating-point and signed integer vectors (<code>VectorF</code> and <code>VectorI</code>, respectively) with between 1 and 4 components.</li>
                    </ul>
                </li>
                <li>
                    <a href="Basic Rendering/UniformCollections.html">UniformCollections.h</a>
                    <ul>
                        <li>Defines various "uniforms", which are shader parameters that can be changed at any time by the software.</li>
                    </ul>
                </li>
                <li>
                    <a href="Basic Rendering/MaterialUsageFlags.html">MaterialUsageFlags</a>
                    <ul>
                        <li>This "Basic Rendering" system provides some built-in shader uniforms that any material can use.</li>
                        <li>This data structure stores which of these built-in shader uniforms will actually be used by a material.</li>
                    </ul>
                </li>
                <li>
                    <a href="Basic Rendering/MaterialConstants.html">MaterialConstants</a>
                    <ul>
                        <li>Defines the names of the various buit-in uniforms,
                        as well as functions to generate headers for vertex, fragment, and geometry shaders.</li>
                    </ul>
                </li>
                <li>
                    <a href="Basic Rendering/RenderInfo.html">RenderInfo</a>
                    <ul>
                        <li>Important data that's used to set the built-in uniforms that all materials share.</li>
                    </ul>
                </li>
                <li>
                    <a href="Basic Rendering/Material.html">Material</a>
                    <ul>
                        <li>Represents a single combination of vertex and fragment (and optionally geometry) shader.</li>
                    </ul>
                </li>
            </ul>
        </div>

        <br class="SectionDivider" />
        <br class="SectionDivider" />
        <br class="SectionDivider" />

        <div class="TextSection">
            <h2>How to use this system</h2>
            <p>
                The following is an explanation of how to use this rendering system. Take a look at the
                "SimpleRenderWorld" game world in the "Manbil/Sample Worlds" folder in the engine to see an example of
                these features in action.
            </p>

            <h3>How Meshes are Stored</h3>
            <p>
                Before you can render anything, you must create triangles to render (you could also use other
                shapes, but this will very rarely be necessary unless using the geometry shader). Before diving into
                mesh creation, however, some information about vertex attributes is needed.
            </p>
            <p>
                Each vertex in a mesh contains some number of "attributes". These vertex attributes are needed to
                describe the surface of the triangle so that a material can render it properly. Common attributes
                include "position", "texture coordinate" (also known as "UV coordinate), or "surface normal".
            </p>
            <p>
                As a side note, these attributes are organized contiguously;
                in other words, in contrast to engines like Unity that have different parallel arrays for each attribute
                ("a struct of arrays"), this system assumes the vertices are stored in a single array,
                and each individual vertex's attributes are stored together in a single block ("an array of structs").
                For example, there is a pre-defined "VertexPosUV" data structure in
                <a href="Basic Rendering/Vertices.html">Vertices.h</a> representing a vertex with 3D position and 2D
                texture coordinate attributes, in that order. To create a mesh that has these types of vertices, you
                would create and fill an array of "VertexPosUV", whereas in Unity you would create and fill an array of
                "positions" and a separate parallel array of "UVs". There is no clear performance advantage for either
                method; it is mostly a stylistic choice.
            </p>
            <p>
                If you only set vertices when creating a mesh (and assuming you are using a normal triangle list instead
                of a triangle <em>strip</em>, described below), then OpenGL interprets each group of three vertices in
                sequence to be a single triangle. However, this is often an inefficient way to create meshes; you
                would have many duplicate vertices wherever multiple triangles shared the same vertex! For this reason,
                you may also specify a collection of "indices". Once created, every set of three indices can specify a
                single triangle in the mesh, and the vertex list becomes just an ordered collection of vertices that
                the index collection picks from.
            </p>
            <p>
                For example, if you were to create a simple rectangle, you'd need to create two triangles, each representing
                half the rectangle. Without indices, you'd need 6 vertices -- 3 for each of the two triangles. However,
                with indices, you only need four vertices -- one for each corner of the rectangle -- and then 6 indices
                to specify the actual triangles. While obviously the difference between storing 4 and 6 vertices is negligible,
                and you still need all those indices, keep in mind that a) meshes can have thousands of vertices,
                and b) those vertices can have quite a few floats, while indices are just a single unsigned int each.
            </p>
            <p>
                As mentioned before, there is an alternative to indexed vertices known as a "triangle strip". This
                alternative storage method is perfectly valid, but it is rarely much more efficient than indexed
                vertices, and it is beyond the scope of this page. Feel free to refer to the OpenGL documentation or
                one of the many <a href="http://en.wikipedia.org/wiki/Triangle_strip">explanations</a> available online
                to see how triangle strips are defined.
            </p>

            <h3>How to Create Meshes</h3>
            <p>
                In Manbil, vertices are stored in the <a href="Basic Rendering/MeshData.html">MeshData</a> class. Along
                with vertex/index data, the class stores which type of primitive the vertices represent (the option we've
                been talking about is <code class="prettyprint">PrimitiveTypes::PT_TRINANGLE_STRIP</code>) and, optionally,
                a CPU-side copy of the vertex/index data in case you plan to read back the data often.
            </p>
            <p>
                When setting vertex data with the MeshData class, you will need to specify how the data will be used.
                This provides a hint to OpenGL on how to best optimize the data's location in GPU memory; it does
                <em>not</em> have any impact on the data beyond performance/optimization tips for the graphics driver.
                The three options are <code class="prettyprint">MeshData::BUF_STATIC</code> (the most common option:
                the vertex data will never need to be modified later),
                <code class="prettyprint">MeshData::BUF_DYNAMIC</code> (the data will be modified fairly regularly),
                and <code class="prettyprint">MeshData::BUF_STREAM</code> (the data will be modified practically as
                often as it is rendered).
            </p>

            <h3>Creating a Material</h3>
            <p>
                Every material should have at least a vertex and fragment shader.
                Geometry shaders are optional, more complex, and not often used; they will be covered towards the bottom
                of this page.
            </p>
            <p>

            </p>
        </div>

    </body>

 </html>